---
title: "Report: Sample size planning for sequential ANOVAs"
# author: "<i>created by the</i> sprtt <i>package</i> `r print(citation('sprtt'), style = 'text')`"
output:
  html_document:
    theme: flatly
    toc: true
    toc_float: true
    number_sections: true
    # code_folding: hide
params:
  #data_path: !r system.file("sample_tool_data", package = "sprtt")     #"data/sprt_tool_df_all_100.rds"  
  n_rep: 2000
  pick_f_expected: 0.25
  pick_power: 0.8
  pick_k_groups: 3
---

<style>
/* Visually hide headings but keep them in the layout for TOC/scrollspy */
.section.toc-only > h1,
.section.toc-only > h2,
.section.toc-only > h3,
.section.toc-only > h4,
.section.toc-only > h5,
.section.toc-only > h6,
h1.toc-only, h2.toc-only, h3.toc-only, h4.toc-only, h5.toc-only, h6.toc-only {
  position: absolute !important;
  left: -9999px !important;
  width: 1px !important;
  height: 1px !important;
  overflow: hidden !important;
  /* keep a tiny footprint so scrollspy can detect position */
}

/* Nice: when navigated via TOC, show a subtle marker for a moment */
.section.toc-only:target::before {
  content: "";
  display: block;
  height: 0;
  margin-top: -8px;
  border-top: 2px solid #bbb;
}
</style>

```{r, include=FALSE}
knitr::opts_chunk$set(warning = FALSE, message = FALSE, echo = FALSE)
```

```{r, include=FALSE}
n_rep = params$n_rep
pick_f_expected = params$pick_f_expected
pick_power = params$pick_power
pick_k_groups = params$pick_k_groups

library(dplyr)
library(tidyr)
library(kableExtra)
library(gridExtra)
library(glue)
library(here)
library(ggplot2)
library(knitr)
library(kableExtra)
library(gt)
library(ggtext)
library(scales)
library(latex2exp)
```


```{r, include=FALSE}
# data -------------------------------------------------------------------------
#load(glue("{params$data_path}/sprt_tool_samples_{n_rep}.RData"))
# load(glue("meta_data/sprt_tool_samples_{n_rep}.RData"))

  # if (is.null(df)) df <- sprtt:::df
  # if (is.null(df_all)) df_all <- sprtt:::df_all
```


```{r, include=FALSE}
# variables --------------------------------------------------------------------
digits <- 2

palette <- "RdYlBu"  #"Dark2"
light_green <- "#a5d1c7"
green <- "#69b3a2"
dark_green <- "#548f81"
dark2_green <- "#104949"
light_blue <- "#cce5ff" 
grey_blue <- "#bccfe5"
blue <- "#2c7bb6"  #"#404080"
dark_blue <- "#1b3c70"
magenta <- "#e61be5"
rosa <- "#ff0088"
hell_rosa <- "#ffa1c2"
light_red <- "#e72b2e"
red <- "#d7191c"

# red <- 	"#d7191c" #"#ca0020" "#CD2626" "#8B0000"
dark_red <- "#8b1012"
black_red <- "#4b1919" # "#651718"

light_orange <- "#fffcf9"
orange <- "#fdae61"
dark_orange <- "#fc8715"
yellow <- "#ffffbf"

# Define Flatly-compatible accent colors (muted, modern)
light_green       <- "#18BC9C"  # Flatly teal
flatly_yellow     <- "#F1C40F"  # gold
light_red         <- "#E74C3C"  # Flatly red
flatly_red_dark   <- "#C0392B"  # darker red
flatly_blue       <- "#387ba8"  # Accent for lines
flatly_dark       <- "#2c3e50"  # blue of the theme
flatly_purple     <- "#A569BD"  # amethyst
flatly_gray_light <- "#ECF0F1"  # very light gray (bg)
flatly_gray_dark  <- "#7F8C8D"  # dark gray
flatly_border     <- "#BDC3C7"  # subtle borders

fixed_color <- light_red

dpi = 150
base_size <- 30
linewidth = 1.5
theme_set(theme_bw(base_size = base_size))

```


```{r, echo=FALSE, results='asis', warning=FALSE}
# sprtt_cit <- paste(format(citation("sprtt"), style = "text"), collapse = " ")
# sprtt_cit <- gsub("_(.+?)_", "<em>\\1</em>", sprtt_cit, perl = TRUE)
# 
# # Match the last angle-bracket URL by greedily capturing the prefix
# sprtt_cit <- sub("(?s)^(.*)&lt;\\s*(https?://[^&\\s]+)\\s*&gt;(.*)$",
#                  '\\1<br><a href="\\2" target="_blank" rel="noopener">\\2</a>\\3',
#                  sprtt_cit, perl = TRUE)
# sprtt_cit <- sub("(?s)^(.*)<\\s*(https?://[^>\\s]+)\\s*>(.*)$",
#                  '\\1<br><a href="\\2" target="_blank" rel="noopener">\\2</a>\\3',
#                  sprtt_cit, perl = TRUE)
# 
# cat(sprintf(
#   '<p class="author-line"><i>created by the</i> [sprtt](https://meikesteinhilber.github.io/sprtt/) <i>package</i><br>
#    <cite style="font-size:0.85em;color:#555;line-height:1.4;overflow-wrap:anywhere;">%s</cite></p>',
#   sprtt_cit
# ))
# 
sprtt_cit <- paste(format(citation("sprtt"), style = "text"), collapse = " ")
sprtt_cit <- gsub("_(.+?)_", "<em>\\1</em>", sprtt_cit, perl = TRUE)

# Remove URLs in angle brackets (both escaped & literal), plus a trailing dot if present
sprtt_cit <- gsub("&lt;\\s*https?://[^&\\s>]+\\s*&gt;\\.?","", sprtt_cit, perl=TRUE)
sprtt_cit <- gsub("<\\s*https?://[^>\\s]+\\s*>\\.?","", sprtt_cit, perl=TRUE)

# (Optional) also remove bare URLs that might appear without <...>
sprtt_cit <- gsub("\\bhttps?://[^\\s<>]+\\b\\.?","", sprtt_cit, perl=TRUE)

# Clean up leftover spaces/punctuation
sprtt_cit <- gsub("\\s+,", ",", sprtt_cit)
sprtt_cit <- gsub("\\s+\\.", ".", sprtt_cit)
sprtt_cit <- gsub("\\s{2,}", " ", sprtt_cit)
sprtt_cit <- trimws(sprtt_cit)

cat(sprintf(
  '<p class="author-line"><i>created by the</i> <a href="https://meikesteinhilber.github.io/sprtt/" target="_blank" rel="noopener">sprtt</a> <i>package</i><br>
   <cite style="font-size:0.85em;color:#555;line-height:1.4;">%s</cite></p>',
  sprtt_cit
))


```



<br><br>

### Overview {#txt-overview .unlisted .unnumbered}

This report provides practical guidance for planning a study with **sequential ANOVA**, where the final sample size is not fixed in advance.

**Chapter 1** illustrates the consequences of choosing a target effect size $f_{\text{exp}}$ across a range of possible true effects $f_{\text{true}}$. Although not specific to sequential designs, this perspective is essential for selecting a sensible expected effect size.

**Chapter 2** presents the core planning results for a sequential study, focusing on two benchmark cases: (a) the true effect equals the specified value ($f_{\text{true}} = f_{\text{exp}}$) and (b) there is no true effect ($f_{\text{true}} = 0$).

**Chapter 3** offers extended plots and tables to explore additional scenarios with more varied $f_{\text{true}}$ values.


## Simulation details {#txt-sim .unlisted .unnumbered}

The following results are based on a simulation with `r n_rep` iterations per condition.
Data were generated from a normal distribution, $\mathcal{N}(\mu,\sigma^2)$, under equal variances across groups and strictly balanced group sizes throughout data collection.

The analyses below use the following specifications:

 - $f_{exp}$ = `r pick_f_expected`

 - Power ($1-\beta$) = `r pick_power`

 - *k* groups = `r pick_k_groups`
 
 - $\alpha$ = 0.05
 
See XXX for the simulation code.

<br>

## Influence of $f_{exp}$

Choosing $f_{\text{exp}}$ is critical because it determines (i) which effect sizes can be detected with the target power and (ii) how much data (sample size) are typically required to reach a decision.

In this report, the specified effect size is $f_{\text{exp}} = `r pick_f_expected`$.
The plot below shows the power curve across possible true effects in the population, $f_{\text{true}}$.

It is recommended to set $f_{\text{exp}}$ to the **minimum effect of interest**: power declines quickly for effects smaller than $f_{\text{exp}}$, whereas choosing a much larger $f_{\text{exp}}$ may shorten data collection but risks missing practically relevant effects just below that value.


### Power curve {#power-curve .toc-only}

```{r, fig.height=10, fig.width=15, out.width="100%", fig.align="left"}
plot_cases <- df_all %>% 
  mutate(fill_group = factor(as.integer(f_simulated))) %>% 
  filter(f_expected == pick_f_expected,
         power == pick_power,
         k_groups == pick_k_groups
  ) %>% 
  filter(f_simulated != 0) %>% 
  group_by(
    f_simulated,
    f_expected,
    k_groups,
    alpha,
    power,
    distribution,
    sd,
    sample_ratio) %>% 
  mutate(
    decision_status_50 = if_else(decision != "continue sampling" & n <= q50_n, 1, 0),
    decision_status_75 = if_else(decision != "continue sampling" & n <= q75_n, 1, 0),
    decision_status_90 = if_else(decision != "continue sampling" & n <= q90_n, 1, 0),
    decision_status_95 = if_else(decision != "continue sampling" & n <= q95_n, 1, 0),
    decision_status_100 = if_else(decision != "continue sampling", 1, 0)
  ) %>% 
  summarize(
    error_rate = mean(decision_error),
    mean_n = mean(n),
    median_n = median(n),
    q90_n = quantile(n, 0.90),
  ) %>% mutate(
    simulated_power = if_else(f_simulated != 0, 1 - error_rate, NA),
    .after = power
  )

# 1) Build a dense x-grid and linearly interpolate simulated_power
rng  <- range(plot_cases$f_simulated)
grid <- tibble(f_simulated = seq(rng[1], rng[2], length.out = 1000))
grid$simulated_power <- with(plot_cases,
  approx(x = f_simulated, y = simulated_power, xout = grid$f_simulated,
         method = "linear", rule = 2)$y
)

# 2) Compute above/below and y-bounds for one ribbon layer
shade <- grid %>%
  mutate(
    above  = simulated_power >= pick_power,
    ymin   = pmin(simulated_power, pick_power),
    ymax   = pmax(simulated_power, pick_power)
  )

# 3) Plot: one ribbon (colored by above/below), then your original line/points
ggplot() +
  geom_ribbon(
    data = shade,
    aes(x = f_simulated, ymin = ymin, ymax = ymax, fill = above),
    alpha = 0.25, colour = NA
  ) +
  scale_fill_manual(values = c(`TRUE` = light_green, `FALSE` = light_red), guide = "none") +
  geom_line(data = plot_cases, aes(f_simulated, simulated_power),
            linewidth = 1.2, colour = flatly_dark) +
  geom_point(data = plot_cases, aes(f_simulated, simulated_power),
             size = 3.8, colour = flatly_blue, fill = flatly_blue,
             shape = 21, stroke = 1.2) +
  geom_hline(yintercept = pick_power, linetype = "dashed", colour = flatly_dark) +
  scale_y_continuous(limits = c(0, 1.1), breaks = seq(0, 1, by = 0.25),
                     labels = scales::percent_format(accuracy = 1)) +
  scale_x_continuous(expand = expansion(mult = c(0.02, 0.02)),
                     breaks = unique(plot_cases$f_simulated)) +
  labs(
    title = "Simulated power across true effect sizes",
    x = expression(italic(f)[true]),
    y = "Simulated power",
    subtitle = glue::glue(
      "<i>f</i><sub>exp</sub> = {pick_f_expected}, ",
      "1 - &beta; = {pick_power}, ",
      "&alpha; = 0.05, groups = {pick_k_groups}"
    )
  ) +
  theme_minimal(base_size = base_size) +
  theme(
    text = element_text(colour = flatly_dark),   # <-- sets ALL text to blue
    plot.title = element_text(face = "bold", size = base_size, hjust = 0, colour = flatly_dark),
    plot.subtitle = ggtext::element_markdown(size = base_size*0.7, colour = "grey40"),
    axis.title = element_text(face = "bold"),
    axis.text  = element_text(colour = "grey20"),
    panel.grid.minor = element_blank(),
    panel.grid.major.x = element_blank(),
    legend.position = "none",
    plot.title.position = "plot"
  )  -> plot


if (pick_f_expected == 0.10){
  plot + annotate(
    "text",
    x = min(plot_cases$f_simulated),
    y = pick_power,
    label = paste0(" target power = ", percent(pick_power)),
    hjust = 0,
    vjust = 2,
    size = base_size * 0.25,
    colour = flatly_dark
  )
    
} else{
    plot + annotate(
    "text",
    x = min(plot_cases$f_simulated),
    y = pick_power + 0.1,
    label = paste0(" target power = ", percent(pick_power)),
    hjust = 0,
    vjust = 2,
    size = base_size * 0.25,
    colour = flatly_dark
  )
}

```

### Sequential vs fixed design {#sample-size-diff .toc-only}

This plot visualizes the rewuired sample sizes, when the true vaue is set and one uses different 

```{r, fig.height=10, fig.width=15, out.width="100%", fig.align="left"}

pick_f_simulated = 0.30

# titles
title_html <- glue("<i>f</i><sub>true</sub> = {pick_f_simulated}")
subtitle_html <- glue(
  # "<i>f</i><sub>true</sub> = {pick_f_expected},<br>",
  "1 - &beta; = {pick_power}, &alpha; = 0.05,<br> groups = {pick_k_groups}"
)

df_all %>% 
  mutate(f_simulated = factor(f_simulated, levels = sort(unique(pick_f_simulated))),
         fill_group = factor(as.integer(f_simulated))
         ) %>% 
  filter(f_simulated == pick_f_simulated,
         f_expected <= pick_f_simulated,
         power == pick_power,
         k_groups == pick_k_groups
  ) %>%
  mutate(f_expected = factor(f_expected)) %>% 
  group_by(f_expected) %>% 
  # filter(f_simulated %in% pick_f_simulated) %>%
  {. ->> cases} %>% 
  ggplot(aes(x = f_expected, y = n)) +
  geom_violin(trim = FALSE, fill = light_blue,
              scale = "count",
              #draw_quantiles = c(0.25, 0.50, 0.75),
              linewidth = 0.3) +
  # scale_fill_manual(values = light_blue) +
  geom_point(aes(x = f_expected, y = fix_n),
             position = position_dodge(0.9),
             shape = 18,
             color = fixed_color,
             size = 9) +
  geom_point(aes(x = f_expected, y = mean_n),
             position = position_dodge(0.9),
             shape = 15,
             color = flatly_dark,
             size = 6) + 
  labs(
    x = "<i>f</i><sub>exp</sub>",
    y = "sample size",
    title = "Required sample sizes to reach a decision",
    subtitle = as.expression(bquote(paste(italic(f)[true], " = ", .(pick_f_expected)))),
    caption = subtitle_html) +
    theme_minimal(base_size = base_size) +
    theme(plot.title = element_text(face = "bold", size = base_size, hjust = 0, colour = flatly_dark),
        plot.subtitle = element_text(size = base_size*0.7, colour = "grey40"),
        plot.caption = element_markdown(),
        axis.title.x = element_markdown(),
        panel.grid.minor.y = element_blank(),
        panel.grid.major.x = element_blank()
        ) -> p_violin 
p_violin
```

## Sample size recommendations

### plot {#plot .toc-only} 

```{r, fig.height=9, fig.width=10, out.width="70%", fig.align="left"}
pick_f_simulated = c(0, pick_f_expected)
# pick_f_simulated = pick_f_expected

# titles
title_html <- glue("<i>f</i><sub>exp</sub> = {pick_f_expected}")
subtitle_html <- glue(
  # "<i>f</i><sub>true</sub> = {pick_f_expected},<br>",
  "1 - &beta; = {pick_power}, &alpha; = 0.05,<br> groups = {pick_k_groups}"
)

df_all %>% 
  mutate(f_simulated = factor(f_simulated, levels = sort(unique(pick_f_simulated))),
         fill_group = factor(as.integer(f_simulated))) %>% 
  filter(f_expected == pick_f_expected,
         power == pick_power,
         k_groups == pick_k_groups
  ) %>% 
  filter(f_simulated %in% pick_f_simulated) %>%
  {. ->> cases} %>% 
  ggplot(aes(x = f_simulated, y = n)) +
  geom_violin(trim = FALSE, fill = light_blue,
              scale = "count",
              #draw_quantiles = c(0.25, 0.50, 0.75),
              linewidth = 0.3) +
  # scale_fill_manual(values = light_blue) +
  geom_point(aes(x = f_simulated, y = fix_n),
             position = position_dodge(0.9),
             shape = 18,
             color = fixed_color,
             size = 11) +
  geom_point(aes(x = f_simulated, y = mean_n),
             position = position_dodge(0.9),
             shape = 15,
             color = flatly_dark,
             size = 8) + 
  labs(
    x = "<i>f</i><sub>true</sub>",
    y = "sample size",
    title = "Required sample sizes to reach a decision",
    subtitle = as.expression(bquote(paste(italic(f)[exp], " = ", .(pick_f_expected)))),
    caption = subtitle_html  ) +
    theme_minimal(base_size = base_size) +
  theme(plot.title = element_text(face = "bold", size = base_size, hjust = 0, colour = flatly_dark),
        plot.subtitle = element_text(size = base_size*0.7, colour = "grey40"),
        plot.caption = element_markdown(),
        axis.title.x = element_markdown(),
        panel.grid.minor.y = element_blank(),
        panel.grid.major.x = element_blank()
        ) -> p_violin 
p_violin
```

### summary table {#table .toc-only}

```{r}
table_cases <- df_all %>% 
  mutate(f_simulated = factor(f_simulated, levels = sort(unique(pick_f_simulated))),
         fill_group = factor(as.integer(f_simulated))) %>% 
  filter(f_expected == pick_f_expected,
         power == pick_power,
         k_groups == pick_k_groups
  ) %>% 
  filter(f_simulated %in% pick_f_simulated) %>% 
    group_by(
    f_simulated,
    f_expected,
    k_groups,
    alpha,
    power,
    distribution,
    sd,
    sample_ratio) %>% 
  mutate(
    decision_status_50 = if_else(decision != "continue sampling" & n <= q50_n, 1, 0),
    decision_status_75 = if_else(decision != "continue sampling" & n <= q75_n, 1, 0),
    decision_status_90 = if_else(decision != "continue sampling" & n <= q90_n, 1, 0),
    decision_status_95 = if_else(decision != "continue sampling" & n <= q95_n, 1, 0),
    decision_status_100 = if_else(decision != "continue sampling", 1, 0)
  ) %>% 
  group_by(f_simulated, f_expected, power) %>%
  summarize(
    decision_error_rate = mean(decision_error),
    fix_n = as.integer(mean(fix_n)),
    mean_n = as.integer(round(mean(n))),
    median_n = as.integer(median(n)),
    min_n = as.integer(min(n)),
    max_n = max(n),
    decision_rate_100 = sum(decision_status_100)/n(),
    q25_n = as.integer(round(quantile(n, 0.25))),
    q50_n = as.integer(round(quantile(n, 0.50))),
    q75_n = as.integer(round(quantile(n, 0.75))),
    q80_n = as.integer(round(quantile(n, 0.80))),
    q85_n = as.integer(round(quantile(n, 0.85))),
    q90_n = as.integer(round(quantile(n, 0.90))),
    q95_n = as.integer(round(quantile(n, 0.95))),
    sd_error_n  = sd(n)/sqrt(length((n))),
    decision_rate_50 = sum(decision_status_50)/n(),
    decision_rate_75 = sum(decision_status_75)/n(),
    decision_rate_90 = sum(decision_status_90)/n(),
    decision_rate_95 = sum(decision_status_95)/n()
  ) %>% mutate(
    simulated_power = if_else(f_simulated != 0, 1 - decision_error_rate, NA),
    .after = power
  ) %>% 
  select(-power) %>% 
    ungroup() %>%
    select(
    f_simulated,
    # f_expected,
    simulated_power,
    decision_error_rate,
    mean_n,
    median_n,
    min_n,
    max_n,
    # decision_rate_90,
    q75_n,
    q80_n,
    q85_n,
    q90_n,
    q95_n,
    fix_n
    # decision_rate_95,
  ) %>% 
  mutate()
  # mutate(f_simulated = as.double(f_simulated))

table_cases %>%
  ungroup() %>% 
  mutate(decision_error_rate = decision_error_rate) %>% 
  gt() %>%
  sub_missing(columns = simulated_power, missing_text = "-") %>% 
  tab_header(
    title = gt::html("<i>Summary Table</i>"),
    subtitle = gt::html(glue("<i>f</i><sub>exp</sub> = {pick_f_expected}"))
  ) %>%
  # center all data columns
  cols_align(align = "center", columns = everything()) %>%
  # center column labels and the heading
  tab_options(
    heading.align = "left"
  ) %>% 
  cols_label(
    f_simulated         = gt::html("<i>f</i><sub>true</sub>"),
    # f_expected          = gt::html("<i>f</i><sub>exp</sub>"),
    simulated_power     = "simulated power",
    decision_error_rate = "Error rate %",
    fix_n               = html("Reference <i>N</i>:<br>fixed design"),
    mean_n              = "Mean",
    median_n            = "Median",
    min_n               = "Min",
    max_n               = "Max",
    # decision_rate_90    = "90% decision rate",
    q75_n               = "75%",
    q80_n               = "80%",
    q85_n               = "85%",
    q90_n               = "90%",
    q95_n               = "95%"
    # decision_rate_95    = "95% decision rate"
  ) %>%
   # high-level headers (spanners)
  tab_spanner(
    label   = "Sample size (N)",
    columns = c(mean_n, median_n, min_n, max_n)
  ) %>%
  tab_spanner(
    label   = html("<i>N</i> to reach decision rate (%)"),
    columns = c(q75_n, q80_n, q85_n, q90_n, q95_n)
  ) %>%
  # tab_spanner(
  #   label   = html("Reference fixed design N"),
  #   columns = c(fix_n)
  # ) %>%
  data_color(
    columns = q90_n,
    palette = grey_blue
  ) %>%
  data_color(
    columns = fix_n,
    palette = "darkgrey"
  ) %>%
  fmt_number(
    columns = where(is.double),
    decimals = 2
  )


```


## Extended Results: Various true effects

```{r}
pick_f_simulated = c(0,
                     pick_f_expected - 0.05,
                     pick_f_expected,
                     pick_f_expected + 0.05)
```


### Required sample sizes {#extended-violin .toc-only}

This violin plot shows the distribution of required sample sizes $n$ across simulations for different assumed true effects $f_{\text{true}}$.
Each violin summarizes how often a given $n$ occurred: wider sections indicate that sample sizes in that range were more frequent.

The violin colors indicate whether the test achieves the target power at each true effect.

  - **Blue** marks settings where $f_{\text{true}} \geq f_{\text{exp}}$ (or $f_{\text{true}} = 0$); at these settings the test reaches the target power $1-\beta$ = `r pick_power`.
  
  - **Red** marks settings where power falls short, so such effects would often not be detected with the specified power `r pick_power` at significance level $\alpha$ = 0.05. If `f_expected = 0.1` is selected, no red violin is shown as it is outside of the simulated scope.


The red diamond marks the fixed sample size from an a priori power analysis, and the blue square shows the mean sample size observed across simulations.


```{r, fig.height=10, fig.width=15, out.width="100%", fig.align="left"}
# violin_colors <- c(light_blue, hell_rosa, light_blue, light_blue)

# title_html <- glue("<i>f</i><sub>exp</sub> = {pick_f_expected}")
caption_html <- glue(
  "1 - &beta; = {pick_power}, &alpha; = 0.05,<br>",
  "groups = {pick_k_groups}"
)


p_violin <- df_all %>%
  mutate(
    f_simulated = factor(f_simulated, levels = sort(unique(pick_f_simulated))),
    fill_label = ifelse(f_simulated == pick_f_expected - 0.05,
                        "not enough power",
                        "enough power")
  ) %>%
  filter(
    f_expected == pick_f_expected,
    power == pick_power,
    k_groups == pick_k_groups
  ) %>%
  filter(f_simulated %in% pick_f_simulated) %>%
  ggplot(aes(x = as.factor(f_simulated), y = n, fill = fill_label)) +
  
  # violins (fill legend only)
  geom_violin(
    trim = FALSE,
    scale = "count",
    # draw_quantiles = c(0.25, 0.50, 0.75),
    # linewidth = 0.1,
    color = "lightgrey"
  ) +
  scale_fill_manual(
    name = "Power",
    values = c("enough power" = light_blue,
               "not enough power" = hell_rosa)
  ) +
  
  # red diamond = fixed sample size
  geom_point(
    aes(y = fix_n, color = "Fixed sample size"),
    position = position_dodge(0.9),
    shape = 18,     # diamond, no border
    size  = 7,
    stroke = 0      # ensures no black outline
  ) +
  
  # blue square = mean sample size
  geom_point(
    aes(y = mean_n, color = "Mean sample size"),
    position = position_dodge(0.9),
    shape = 15,     # square, no border
    size  = 6,
    stroke = 0      # ensures no black outline
  ) +
scale_color_manual(
  name   = "Legend",
  values = c("Fixed sample size" = fixed_color,
             "Mean sample size"  = flatly_dark),
  labels = c("Fixed sample size" = "a priori power analysis",
             "Mean sample size"  = "mean sample size")
) +
  labs(
    x = "<i>f</i><sub>true</sub>",
    y = "sample size",
    title = "Required sample sizes to reach a decision",
    subtitle = as.expression(bquote(paste(italic(f)[exp], " = ", .(pick_f_expected)))),
    caption = caption_html  
  ) +
  
  # clean legend appearance
  guides(
    fill  = guide_legend(override.aes = list(shape = NA)),  # patches only
    color = guide_legend(override.aes = list(stroke = 0, size = 5)) # points only
  ) +
  theme_minimal(base_size = base_size) +
  theme(
    legend.key = element_blank(),  # no background box around keys
    # plot.title = element_markdown(),
    # plot.subtitle = element_markdown(),
    plot.caption = element_markdown(),
    axis.title.x = element_markdown(),
    # panel.grid.minor.y = element_blank(),
    panel.grid.minor.x = element_blank(),
    panel.grid.major.x = element_blank(),
    plot.title = element_text(face = "bold", size = base_size, hjust = 0, colour = flatly_dark),
    plot.subtitle = element_text(size = base_size*0.7, colour = "grey40")
  ) 

p_violin


```


### summary table {#extended-table .toc-only}

```{r}
table_cases <- df_all %>% 
  mutate(f_simulated = factor(f_simulated, levels = sort(unique(pick_f_simulated))),
         fill_group = factor(as.integer(f_simulated))) %>% 
  filter(f_expected == pick_f_expected,
         power == pick_power,
         k_groups == pick_k_groups
  ) %>% 
  filter(f_simulated %in% pick_f_simulated) %>% 
    group_by(
    f_simulated,
    f_expected,
    k_groups,
    alpha,
    power,
    distribution,
    sd,
    sample_ratio) %>% 
  mutate(
    decision_status_50 = if_else(decision != "continue sampling" & n <= q50_n, 1, 0),
    decision_status_75 = if_else(decision != "continue sampling" & n <= q75_n, 1, 0),
    decision_status_90 = if_else(decision != "continue sampling" & n <= q90_n, 1, 0),
    decision_status_95 = if_else(decision != "continue sampling" & n <= q95_n, 1, 0),
    decision_status_100 = if_else(decision != "continue sampling", 1, 0)
  ) %>% 
  group_by(f_simulated, f_expected, power) %>%
  summarize(
    decision_error_rate = mean(decision_error),
    fix_n = as.integer(mean(fix_n)),
    mean_n = as.integer(round(mean(n))),
    median_n = as.integer(median(n)),
    min_n = as.integer(min(n)),
    max_n = max(n),
    decision_rate_100 = sum(decision_status_100)/n(),
    q25_n = as.integer(round(quantile(n, 0.25))),
    q50_n = as.integer(round(quantile(n, 0.50))),
    q75_n = as.integer(round(quantile(n, 0.75))),
    q80_n = as.integer(round(quantile(n, 0.80))),
    q85_n = as.integer(round(quantile(n, 0.85))),
    q90_n = as.integer(round(quantile(n, 0.90))),
    q95_n = as.integer(round(quantile(n, 0.95))),
    sd_error_n  = sd(n)/sqrt(length((n))),
    decision_rate_50 = sum(decision_status_50)/n(),
    decision_rate_75 = sum(decision_status_75)/n(),
    decision_rate_90 = sum(decision_status_90)/n(),
    decision_rate_95 = sum(decision_status_95)/n()
  ) %>% mutate(
    simulated_power = if_else(f_simulated != 0, 1 - decision_error_rate, NA),
    .after = power
  ) %>% 
  select(-power) %>% 
    ungroup() %>%
    select(
    f_simulated,
    # f_expected,
    simulated_power,
    decision_error_rate,
    mean_n,
    median_n,
    min_n,
    max_n,
    # decision_rate_90,
    q75_n,
    q80_n,
    q85_n,
    q90_n,
    q95_n,
    fix_n
    # decision_rate_95,
  ) %>% 
  mutate()
  # mutate(f_simulated = as.double(f_simulated))

# num_cols <- colnames(table_cases)
num_cols <- c("f_simulated", "simulated_power", "decision_error_rate")

table_cases %>%
  ungroup() %>% 
  # mutate(decision_error_rate = decision_error_rate) %>% 
  gt() %>%
    # Percent columns (show "-" for NA)
  sub_missing(columns = simulated_power, missing_text = "-") %>% 
  tab_header(
    title = gt::html("<i>Summary Table</i>"),
    subtitle = gt::html(glue("<i>f</i><sub>exp</sub> = {pick_f_expected}"))
  ) %>%
  # center all data columns
  cols_align(align = "center", columns = everything()) %>%
  # center column labels and the heading
  tab_options(
    heading.align = "left"
  ) %>% 
  cols_label(
    f_simulated         = gt::html("<i>f</i><sub>true</sub>"),
    # f_expected          = gt::html("<i>f</i><sub>exp</sub>"),
    simulated_power     = "simulated power",
    decision_error_rate = "Error rate %",
    fix_n               = html("Reference <i>N</i>:<br>fixed design"),
    mean_n              = "Mean",
    median_n            = "Median",
    min_n               = "Min",
    max_n               = "Max",
    # decision_rate_90    = "90% decision rate",
    q75_n               = "75%",
    q80_n               = "80%",
    q85_n               = "85%",
    q90_n               = "90%",
    q95_n               = "95%"
    # decision_rate_95    = "95% decision rate"
  ) %>%
   # high-level headers (spanners)
  tab_spanner(
    label   = "Sample size (N)",
    columns = c(mean_n, median_n, min_n, max_n)
  ) %>%
  tab_spanner(
    label   = html("<i>N</i> to reach decision rate (%)"),
    columns = c(q75_n, q80_n, q85_n, q90_n, q95_n)
  ) %>%
  data_color(
    columns = all_of(num_cols),
    rows    = as.numeric(as.character(f_simulated)) < pick_f_expected &
              as.numeric(as.character(f_simulated)) != 0,
    colors  = hell_rosa, alpha = 0.20) %>% 
  data_color(
    columns = q90_n,
    palette = grey_blue
  ) %>%
  data_color(
    columns = fix_n,
    palette = "darkgrey"
  ) %>%
  fmt_number(
    columns = where(is.double),
    decimals = 2
  )


```




### cumulative {#extended-cumulative .toc-only}

```{r, fig.height=10, fig.width=15, out.width="100%", fig.align="left"}
df_cum <- df_all %>%
  filter(f_expected == pick_f_expected,
         power      == pick_power,
         k_groups   == pick_k_groups) %>% 
  filter(f_simulated == 0 |
         f_simulated >= pick_f_expected) %>% 
  filter(decision != "continue sampling") %>%
  transmute(f_simulated,fix_n, n_decision = n) %>% 
  group_by(f_simulated) %>%
  arrange(n_decision, .by_group = TRUE) %>%
  mutate(cum_prop = row_number() / n()) %>%
  ungroup()

# 4) Find the minimum n that achieves at least 90% decided
cut90 <- df_cum %>%
  group_by(f_simulated) %>%
  summarise(n_at_90 = min(n_decision[cum_prop >= 0.90]), .groups = "drop")

# 5) Plot: ECDF of decision n, with a 90% line and vertical markers at n_at_90
ggplot(df_cum, aes(x = n_decision, y = cum_prop, colour = factor(f_simulated), group = f_simulated)) +
  geom_step(linewidth = 1.1) +
  # Horizontal 90% line
  geom_hline(yintercept = 0.90, linetype = "dotted", colour = flatly_dark) +
  geom_vline(xintercept = unique(df_cum$fix_n), color = flatly_dark,  linetype = "dashed") +
  annotate(
  "text",
  x = unique(df_cum$fix_n) + (unique(df_cum$fix_n) * 0.05),
  y = 0.05,
  label = "fixed sample size",
  angle = 90,         # rotate text
  hjust = 0.1,
  vjust = 0.1,
  size = base_size * 0.25,
  colour = flatly_dark
) +
  scale_y_continuous(
    limits = c(0, 1),
    breaks = c(0, 0.25, 0.5, 0.75, 0.9, 1),
    labels = percent_format(accuracy = 1)
  ) +
  scale_color_brewer(palette = "Set2") +   # modern pastel Flatly-compatible palette
  labs(
    x = "Sample size n",
    y = "",  #"Cumulative proportion\nwith a decision",
    colour = expression(italic(f)[true]),
    title = "Cumulative decision proportions across simulated\neffect sizes",
    # subtitle = "Dashed line: 90% decision threshold"
    subtitle = as.expression(
      bquote(paste(italic(f)[exp], " = ", .(pick_f_expected))))
  ) +
  theme_minimal(base_size = base_size) +
  theme(
    plot.title = element_text(face = "bold", size = base_size, hjust = 0, colour = flatly_dark),
    plot.subtitle = element_text(size = base_size * 0.7, colour = "grey40"),
    panel.grid.minor = element_blank(),
    panel.grid.major.x = element_blank(),
    #legend.position = "bottom",
    # legend.box = "horizontal",
    legend.title = element_text(face = "bold"),
    axis.title = element_text(face = "bold"),
    plot.title.position = "plot"
  )
```
