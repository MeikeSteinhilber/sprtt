---
title: "Report: Sample size planning for SPRTs"
author: "created by the sprtt package"
output:
  html_document:
    theme: flatly
    toc: true
    toc_float: true
    number_sections: false
    code_folding: hide
params:
  data_path: !r system.file("data", "sprt_tool_samples_100.RData", package = "sprtt")     #"data/sprt_tool_df_all_100.rds"  
  n_rep: 100
  pick_f_expected: 0.25
  pick_power: 0.8
  pick_k_groups: 3
---

```{r, include=FALSE}
knitr::opts_chunk$set(warning = FALSE, message = FALSE)
```

```{r, include=FALSE}
n_rep = params$n_rep
pick_f_expected = params$pick_f_expected
pick_power = params$pick_power
pick_k_groups = params$pick_k_groups

library(dplyr)
library(tidyr)
library(kableExtra)
library(gridExtra)
library(glue)
library(here)
library(ggplot2)
library(knitr)
library(kableExtra)
library(gt)
library(ggtext)
library(scales)
library(latex2exp)
```

```{r, include=FALSE}
load(params$data_path)
# load(glue("meta_data/sprt_tool_samples_{n_rep}.RData"))

# variables -------------------------------------------------------------------
digits <- 2

palette <- "RdYlBu"  #"Dark2"
light_green <- "#a5d1c7"
green <- "#69b3a2"
dark_green <- "#548f81"
dark2_green <- "#104949"
light_blue <- "#cce5ff" 
grey_blue <- "#bccfe5"
blue <- "#2c7bb6"  #"#404080"
dark_blue <- "#1b3c70"
magenta <- "#e61be5"
rosa <- "#ff0088"
hell_rosa <- "#ffa1c2"
light_red <- "#e72b2e"
red <- "#e72b2e"
# red <- 	"#d7191c" #"#ca0020" "#CD2626" "#8B0000"
dark_red <- "#8b1012"
black_red <- "#4b1919" # "#651718"

light_orange <- "#fffcf9"
orange <- "#fdae61"
dark_orange <- "#fc8715"
yellow <- "#ffffbf"

# Define Flatly-compatible accent colors (muted, modern)
light_green <- "#18BC9C"  # Flatly teal
light_red   <- "#E74C3C"  # Flatly red
flatly_blue <- "#387ba8"  # Accent for lines
flatly_dark <- "#2c3e50"  # Accent for lines

dpi = 150
base_size <- 30
linewidth = 1.5
theme_set(theme_bw(base_size = base_size))

```


<br><br>
These results are based on a simulation with `r n_rep` iterations per condition.

See XXX for the simulation code.

<br>

## Core Insights

### Power curve

### Influence of f expected

### violin plot

```{r, fig.height=9, fig.width=7, out.width="40%", fig.align="left"}
# pick_f_simulated = c(0, pick_f_expected)
pick_f_simulated = pick_f_expected

# titles
title_html <- glue("<i>f</i><sub>exp</sub> = {pick_f_expected}")
subtitle_html <- glue(
  "<i>f</i><sub>true</sub> = {pick_f_expected},<br>",
  "1 - &beta; = {pick_power}, &alpha; = 0.05,<br> groups = {pick_k_groups}"
)

df_all %>% 
  mutate(f_simulated = factor(f_simulated, levels = sort(unique(pick_f_simulated))),
         fill_group = factor(as.integer(f_simulated))) %>% 
  filter(f_expected == pick_f_expected,
         power == pick_power,
         k_groups == pick_k_groups
  ) %>% 
  filter(f_simulated %in% pick_f_simulated) %>%
  {. ->> cases} %>% 
  ggplot(aes(x = as.factor(pick_k_groups), y = n)) +
  geom_violin(trim = FALSE, fill = light_blue,
              scale = "count",
              #draw_quantiles = c(0.25, 0.50, 0.75),
              linewidth = 0.3) +
  # scale_fill_manual(values = light_blue) +
  geom_point(aes(x = as.factor(pick_k_groups), y = fix_n),
             position = position_dodge(0.9),
             shape = 18,
             color = red,
             size = 11) +
  geom_point(aes(x = as.factor(pick_k_groups), y = mean(mean_n)),
             position = position_dodge(0.9),
             shape = 15,
             color = dark_blue,
             size = 8) + 
  labs(
    x = "<i>f</i><sub>true</sub>",
    subtitle = title_html,
    caption = subtitle_html  ) +
  theme(plot.title = element_markdown(),
        plot.subtitle = element_markdown(),
        plot.caption = element_markdown(),
        axis.title.x = element_markdown(),
        panel.grid.minor.y = element_blank(),
        panel.grid.major.x = element_blank()
        ) -> p_violin 
p_violin
```

```{r}
table_cases <- df_all %>%
  mutate(f_simulated = factor(f_simulated, levels = sort(unique(pick_f_simulated))),
         fill_group = factor(as.integer(f_simulated))) %>%
  filter(f_expected == pick_f_expected,
         power == pick_power,
         k_groups == pick_k_groups
  ) %>%
  filter(f_simulated %in% pick_f_simulated) %>%
  ungroup() %>% 
  mutate(
    decision_status_50 = if_else(decision != "continue sampling" & n <= q50_n, 1, 0),
    decision_status_75 = if_else(decision != "continue sampling" & n <= q75_n, 1, 0),
    decision_status_90 = if_else(decision != "continue sampling" & n <= q90_n, 1, 0),
    decision_status_95 = if_else(decision != "continue sampling" & n <= q95_n, 1, 0),
    decision_status_100 = if_else(decision != "continue sampling", 1, 0)
  ) %>% 
  summarize(
    alpha_error_rate = mean(decision_error[f_simulated == 0], na.rm = TRUE),
    beta_error_rate = mean(decision_error[f_simulated != 0], na.rm = TRUE),
    mean_n = mean(n),
    median_n = median(n),
    max_n = max(n),
    min_n = min(n),
    decision_rate_100 = sum(decision_status_100)/n(),
    q25_n = quantile(n, 0.25),
    q50_n = quantile(n, 0.50),
    q75_n = quantile(n, 0.75),
    q90_n = quantile(n, 0.90),
    q95_n = quantile(n, 0.95),
    sd_error_n  = sd(n)/sqrt(length((n))),
    decision_rate_50 = sum(decision_status_50)/n(),
    decision_rate_75 = sum(decision_status_75)/n(),
    decision_rate_90 = sum(decision_status_90)/n(),
    decision_rate_95 = sum(decision_status_95)/n()
  )

```


## Extended Results

```{r}
pick_f_simulated = c(0,
                     pick_f_expected - 0.05,
                     pick_f_expected,
                     pick_f_expected + 0.15)
```


### violin

```{r, fig.height=12, fig.width=20, out.width="100%", fig.align="left"}
# violin_colors <- c(light_blue, hell_rosa, light_blue, light_blue)

title_html <- glue("<i>f</i><sub>exp</sub> = {pick_f_expected}")
subtitle_html <- glue(
  # "<i>f</i><sub>true</sub> = {pick_f_expected},<br>",
  "1 - &beta; = {pick_power}, &alpha; = 0.05,<br>",
  "groups = {pick_k_groups}"
)


p_violin <- df_all %>%
  mutate(
    f_simulated = factor(f_simulated, levels = sort(unique(pick_f_simulated))),
    fill_label = ifelse(f_simulated == pick_f_expected - 0.05,
                        "Reference scenario",
                        "Other scenarios")
  ) %>%
  filter(
    f_expected == pick_f_expected,
    power == pick_power,
    k_groups == pick_k_groups
  ) %>%
  filter(f_simulated %in% pick_f_simulated) %>%
  ggplot(aes(x = as.factor(f_simulated), y = n, fill = fill_label)) +
  
  # violins (fill legend only)
  geom_violin(
    trim = FALSE,
    scale = "count",
    draw_quantiles = c(0.25, 0.50, 0.75),
    linewidth = 0.1,
    color = "lightgrey"
  ) +
  scale_fill_manual(
    name = "Scenario",
    values = c("Other scenarios" = light_blue,
               "Reference scenario" = hell_rosa)
  ) +
  
  # red diamond = fixed sample size
  geom_point(
    aes(y = fix_n, color = "Fixed sample size"),
    position = position_dodge(0.9),
    shape = 18,     # diamond, no border
    size  = 7,
    stroke = 0      # ensures no black outline
  ) +
  
  # blue square = mean sample size
  geom_point(
    aes(y = mean_n, color = "Mean sample size"),
    position = position_dodge(0.9),
    shape = 15,     # square, no border
    size  = 6,
    stroke = 0      # ensures no black outline
  ) +
scale_color_manual(
  name   = "Estimates",
  values = c("Fixed sample size" = red,
             "Mean sample size"  = dark_blue),
  labels = c("Fixed sample size" = "Fixed design",
             "Mean sample size"  = "Sequential designs")
) +
  labs(
    x = "<i>f</i><sub>true</sub>",
    subtitle = title_html,
    caption = subtitle_html  
  ) +
  
  # clean legend appearance
  guides(
    fill  = guide_legend(override.aes = list(shape = NA)),  # patches only
    color = guide_legend(override.aes = list(stroke = 0, size = 5)) # points only
  ) +
  theme(
    legend.key = element_blank(),  # no background box around keys
    plot.title = element_markdown(),
    plot.subtitle = element_markdown(),
    plot.caption = element_markdown(),
    axis.title.x = element_markdown(),
    panel.grid.minor.y = element_blank(),
    panel.grid.minor.x = element_blank(),
    panel.grid.major.x = element_blank()
  )

p_violin


```


### table

```{r}
table_cases <- df_all %>% 
  mutate(f_simulated = factor(f_simulated, levels = sort(unique(pick_f_simulated))),
         fill_group = factor(as.integer(f_simulated))) %>% 
  filter(f_expected == pick_f_expected,
         power == pick_power,
         k_groups == pick_k_groups
  ) %>% 
  filter(f_simulated %in% pick_f_simulated) %>% 
    group_by(
    f_simulated,
    f_expected,
    k_groups,
    alpha,
    power,
    distribution,
    sd,
    sample_ratio) %>% 
  mutate(
    decision_status_50 = if_else(decision != "continue sampling" & n <= q50_n, 1, 0),
    decision_status_75 = if_else(decision != "continue sampling" & n <= q75_n, 1, 0),
    decision_status_90 = if_else(decision != "continue sampling" & n <= q90_n, 1, 0),
    decision_status_95 = if_else(decision != "continue sampling" & n <= q95_n, 1, 0),
    decision_status_100 = if_else(decision != "continue sampling", 1, 0)
  ) %>% 
  group_by(f_simulated, f_expected, power) %>%
  summarize(
    decision_error_rate = mean(decision_error),
    fix_n = as.integer(mean(fix_n)),
    mean_n = mean(n),
    median_n = as.integer(median(n)),
    min_n = as.integer(min(n)),
    max_n = max(n),
    decision_rate_100 = sum(decision_status_100)/n(),
    q25_n = quantile(n, 0.25),
    q50_n = quantile(n, 0.50),
    q75_n = quantile(n, 0.75),
    q90_n = quantile(n, 0.90),
    q95_n = quantile(n, 0.95),
    sd_error_n  = sd(n)/sqrt(length((n))),
    decision_rate_50 = sum(decision_status_50)/n(),
    decision_rate_75 = sum(decision_status_75)/n(),
    decision_rate_90 = sum(decision_status_90)/n(),
    decision_rate_95 = sum(decision_status_95)/n()
  ) %>% mutate(
    simulated_power = if_else(f_simulated != 0, 1 - decision_error_rate, NA),
    .after = power
  ) %>% 
  select(-power) %>% 
    ungroup() %>%
    select(
    f_simulated,
    f_expected,
    simulated_power,
    decision_error_rate,
    fix_n,
    mean_n,
    median_n,
    min_n,
    max_n,
    decision_rate_90,
    q95_n,
    decision_rate_95
  )# %>% 
  # mutate(f_simulated = as.double(f_simulated))

table_cases %>%
  ungroup() %>% 
  mutate(decision_error_rate = decision_error_rate) %>% 
  gt() %>%
  tab_header(
    title = gt::html("<i>Summary Table</i>")
  ) %>%
  cols_label(
    f_simulated         = gt::html("<i>f</i><sub>true</sub>"),
    f_expected          = gt::html("<i>f</i><sub>exp</sub>"),
    simulated_power     = "simulated power",
    decision_error_rate = "Error rate %",
    fix_n               = "Fixed n",
    mean_n              = "Mean n",
    median_n            = "Median n",
    min_n               = "Min",
    max_n               = "Max",
    decision_rate_90    = "90% decision rate",
    q95_n               = "95% n",
    decision_rate_95    = "95% decision rate"
  ) %>%
  fmt_number(
    columns = where(is.double),
    decimals = 2
  )


```


### Power curve


```{r, fig.height=10, fig.width=15, out.width="100%", fig.align="left"}
plot_cases <- df_all %>% 
  mutate(fill_group = factor(as.integer(f_simulated))) %>% 
  filter(f_expected == pick_f_expected,
         power == pick_power,
         k_groups == pick_k_groups
  ) %>% 
  filter(f_simulated != 0) %>% 
  group_by(
    f_simulated,
    f_expected,
    k_groups,
    alpha,
    power,
    distribution,
    sd,
    sample_ratio) %>% 
  mutate(
    decision_status_50 = if_else(decision != "continue sampling" & n <= q50_n, 1, 0),
    decision_status_75 = if_else(decision != "continue sampling" & n <= q75_n, 1, 0),
    decision_status_90 = if_else(decision != "continue sampling" & n <= q90_n, 1, 0),
    decision_status_95 = if_else(decision != "continue sampling" & n <= q95_n, 1, 0),
    decision_status_100 = if_else(decision != "continue sampling", 1, 0)
  ) %>% 
  summarize(
    error_rate = mean(decision_error),
    mean_n = mean(n),
    median_n = median(n),
    q90_n = quantile(n, 0.90),
  ) %>% mutate(
    simulated_power = if_else(f_simulated != 0, 1 - error_rate, NA),
    .after = power
  )


plot_cases %>%
  ggplot(aes(x = f_simulated, y = simulated_power)) +
  # Shaded area: above/below target power
  geom_ribbon(
    data = subset(plot_cases, f_simulated >= pick_f_expected),
    aes(ymin = pick_power, ymax = simulated_power),
    fill = light_green, alpha = 0.25
  ) +
  geom_ribbon(
    data = subset(plot_cases, f_simulated < pick_f_expected),
    aes(ymin = simulated_power, ymax = pick_power),
    fill = light_red, alpha = 0.25
  ) +
  geom_line(linewidth = 1.2, colour = flatly_dark) +
  geom_point(size = 3.8, colour = flatly_blue, fill = "white", shape = 21, stroke = 1.2) +
  geom_hline(yintercept = pick_power, linetype = "dashed", colour = "grey50") +
  annotate(
    "text",
    x = min(plot_cases$f_simulated),
    y = pick_power,
    label = paste0(" target power = ", percent(pick_power)),
    hjust = 0,
    vjust = 2,
    size = base_size * 0.3,
    colour = "grey30"
  ) +
  scale_y_continuous(
    limits = c(0, 1),
    breaks = seq(0, 1, by = 0.1),
    labels = percent_format(accuracy = 1)
  ) +
  scale_x_continuous(
    expand = expansion(mult = c(0.02, 0.02)),
    breaks = unique(plot_cases$f_simulated)
  ) +
  labs(
    title    = "Simulated power across true effect sizes",
    x        = expression(italic(f)[true]),
    y        = "Simulated power",
    subtitle = glue(
      "<i>f</i><sub>exp</sub> = {pick_f_expected}, ",
      "1 - &beta; = {pick_power}, ",
      "&alpha; = 0.05, groups = {pick_k_groups}"
    )
  ) +
  theme_minimal(base_size = base_size) +
  theme(
    plot.title = element_text(face = "bold", size = base_size, hjust = 0),
    plot.subtitle = element_markdown(size = base_size*0.7, colour = "grey40"),
    axis.title = element_text(face = "bold"),
    axis.text = element_text(colour = "grey20"),
    panel.grid.minor = element_blank(),
    panel.grid.major.x = element_blank(),
    legend.position = "none",
    plot.title.position = "plot"
  )

```

### cumultative

```{r, fig.height=10, fig.width=12, out.width="100%", fig.align="left"}
df_cum <- df_all %>%
  filter(f_expected == pick_f_expected,
         power      == pick_power,
         k_groups   == pick_k_groups) %>% 
  filter(decision != "continue sampling") %>%
  transmute(f_simulated, n_decision = n) %>% 
  group_by(f_simulated) %>%
  arrange(n_decision, .by_group = TRUE) %>%
  mutate(cum_prop = row_number() / n()) %>%
  ungroup()

# 4) Find the minimum n that achieves at least 90% decided
cut90 <- df_cum %>%
  group_by(f_simulated) %>%
  summarise(n_at_90 = min(n_decision[cum_prop >= 0.90]), .groups = "drop")

# 5) Plot: ECDF of decision n, with a 90% line and vertical markers at n_at_90
ggplot(df_cum, aes(x = n_decision, y = cum_prop, colour = factor(f_simulated), group = f_simulated)) +
  geom_step(linewidth = 1.1) +
  # Horizontal 90% line
  geom_hline(yintercept = 0.90, linetype = "dashed", colour = "grey50") +
  # Vertical markers for 90%-decision points
  # geom_vline(data = cut90, aes(xintercept = n_at_90, colour = factor(f_simulated)),
             # linetype = "dotted", linewidth = 0.9, show.legend = FALSE) +
  # geom_text(
  #   data = cut90,
  #   aes(x = n_at_90, y = 0.92,
  #       label = paste0("n = ", n_at_90),
  #       colour = factor(f_simulated)),
  #   hjust = -0.05, vjust = 0, size = base_size*0.2, show.legend = FALSE
  # ) +
  scale_y_continuous(
    limits = c(0, 1),
    labels = percent_format(accuracy = 1)
  ) +
  scale_color_brewer(palette = "Set2") +   # modern pastel Flatly-compatible palette
  labs(
    x = "Sample size n",
    y = "",  #"Cumulative proportion\nwith a decision",
    colour = expression(italic(f)[true]),
    title = "Cumulative decision proportions across simulated\neffect sizes",
    subtitle = "Dashed line: 90% decision threshold"
  ) +
  theme_minimal(base_size = base_size) +
  theme(
    plot.title = element_text(face = "bold", size = base_size, hjust = 0),
    plot.subtitle = element_markdown(size = base_size*0.7, colour = "grey40"),
    panel.grid.minor = element_blank(),
    panel.grid.major.x = element_blank(),
    #legend.position = "bottom",
    # legend.box = "horizontal",
    legend.title = element_text(face = "bold"),
    axis.title = element_text(face = "bold"),
    plot.title.position = "plot"
  )
```
