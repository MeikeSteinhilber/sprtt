---
title: "Report: Sample size planning for sequential ANOVAs"
# author: "<i>created by the</i> sprtt <i>package</i> `r print(citation('sprtt'), style = 'text')`"
output:
  html_document:
    theme: flatly
    toc: true
    toc_float: 
      collapsed: false
      smooth_scroll: true
    number_sections: false
    toc_depth: 3
    toc_collapsed: false
    # code_folding: hide
params:
  #data_path: !r system.file("sample_tool_data", package = "sprtt")     #"data/sprt_tool_df_all_100.rds"  
  n_rep: 2000
  pick_f_expected: 0.25
  pick_power: 0.95
  pick_k_groups: 3
---


<style>

/* Make the entire page layout wider */
.container-fluid {
  max-width: 1500px !important;  /* Increase from default ~1140px */
  padding-left: 40px !important;
  padding-right: 40px !important;
}

body {
  font-size: 16px;
}

/* Make h3 same size as h2 with more spacing */
h3 {
  font-size: 1.5em !important;
  margin-top: 1.5em !important;
  margin-bottom: 0.8em !important;
}

/* Custom alert box styling */
.alert-info {
  background-color: white !important;
  border: 2px solid #2c3e50 !important;
  border-left: 5px solid #2c3e50 !important;
  color: #2c3e50 !important;
  margin-top: 1.5em !important;
  margin-bottom: 1.5em !important;
  border-radius: 4px !important;
  padding-left: 50px !important;
  position: relative !important;
}

.alert-info::before {
  content: "ðŸ›ˆ";
  position: absolute;
  left: 0;
  top: 0;
  bottom: 0;
  width: 40px;
  background-color: #2c3e50;
  color: white;
  display: flex;
  align-items: center;
  justify-content: center;
  font-size: 1.3em;
  border-radius: 2px 0 0 2px;
}

.alert-warning {
  background-color: white !important;
  border: 2px solid #18bc9c !important;
  border-left: 5px solid #18bc9c !important;
  color: #2c3e50 !important;
  margin-top: 1.5em !important;
  margin-bottom: 1.5em !important;
  border-radius: 4px !important;
  padding-left: 50px !important;
  position: relative !important;
}

.alert-warning::before {
  content: "âš ";
  position: absolute;
  left: 0;
  top: 0;
  bottom: 0;
  width: 40px;
  background-color: #18bc9c;
  color: white;
  display: flex;
  align-items: center;
  justify-content: center;
  font-size: 1.3em;
  border-radius: 2px 0 0 2px;
}

/* Make only top-level TOC items bold */
.tocify-header.list-group {
  font-weight: bold !important;
}

/* Make nested items normal weight */
.tocify-subheader .tocify-item {
  font-weight: normal !important;
}


/* TOC styling */
.tocify {
  width: 30% !important;
  max-width: 300px !important;
  min-width: 250px !important;
  top: 0 !important;  /* Start from top since header is inside now */
}

/* Main content area */
.col-md-9 {
  width: 70% !important;
}

/* Responsive breakpoint */
@media (max-width: 1200px) {
  .tocify, .toc-text-top {
    display: none !important;
  }
  
  .col-md-9 {
    width: 100% !important;
  }
}

/* Remove numbering from level 4 headings and deeper */
.section.level4 h4 .header-section-number,
.section.level5 h5 .header-section-number,
.section.level6 h6 .header-section-number {
  display: none;
}

/* Visually hide headings but keep them in layout */
.section.toc-only > h1,
.section.toc-only > h2,
.section.toc-only > h3,
.section.toc-only > h4,
.section.toc-only > h5,
.section.toc-only > h6,
h1.toc-only, h2.toc-only, h3.toc-only, h4.toc-only, h5.toc-only, h6.toc-only {
  position: absolute !important;
  left: -9999px !important;
  width: 1px !important;
  height: 1px !important;
  overflow: hidden !important;
}

.section.toc-only:target::before {
  content: "";
  display: block;
  height: 0;
  margin-top: -8px;
  border-top: 2px solid #bbb;
}
</style>


```{r, include=FALSE}
knitr::opts_chunk$set(warning = FALSE, message = FALSE, echo = FALSE)
```

```{r, include=FALSE}
n_rep = params$n_rep
pick_f_expected = params$pick_f_expected
pick_power = params$pick_power
pick_k_groups = params$pick_k_groups

library(dplyr)
library(glue)
library(ggplot2)
library(knitr)
library(gt)
library(ggtext)
library(scales)

# library(latex2exp)
# library(here)
# library(tidyr)
# library(kableExtra)
# library(gridExtra)
# library(kableExtra)
```

```{r}
htmltools::tags$script(htmltools::HTML(sprintf("
document.addEventListener('DOMContentLoaded', function() {
  setTimeout(function() {
    var tocify = document.querySelector('.tocify');
    if (tocify) {
      var header = document.createElement('div');
      header.style.padding = '20px';
      header.style.backgroundColor = '#2c3e50';
      header.innerHTML = '<p style=\"font-size: 1.5em; color: white; font-weight: bold; margin: 0;\"><i>f</i><sub>exp</sub> = %s</p>';
      tocify.insertBefore(header, tocify.firstChild);
    }
  }, 100);
});
", pick_f_expected)))
```


```{r, include=FALSE}
# data -------------------------------------------------------------------------
#load(glue("{params$data_path}/sprt_tool_samples_{n_rep}.RData"))
# load(glue("meta_data/sprt_tool_samples_{n_rep}.RData"))

df <- sprtt:::df
df_all <- sprtt:::df_all

# df_all <- getFromNamespace("df_all", "sprtt")
# df     <- getFromNamespace("df",     "sprtt")
```


```{r, include=FALSE}
# variables --------------------------------------------------------------------
digits <- 2

palette <- "RdYlBu"  #"Dark2"
light_green <- "#a5d1c7"
green <- "#69b3a2"
dark_green <- "#548f81"
dark2_green <- "#104949"
light_blue <- "#cce5ff" 
grey_blue <- "#bccfe5"
blue <- "#2c7bb6"  #"#404080"
dark_blue <- "#1b3c70"
magenta <- "#e61be5"
rosa <- "#ff0088"
hell_rosa <- "#ffa1c2"
light_red <- "#e72b2e"
red <- "#d7191c"

# red <- 	"#d7191c" #"#ca0020" "#CD2626" "#8B0000"
dark_red <- "#8b1012"
black_red <- "#4b1919" # "#651718"

light_orange <- "#fffcf9"
orange <- "#fdae61"
dark_orange <- "#fc8715"
yellow <- "#ffffbf"

# Define Flatly-compatible accent colors (muted, modern)
light_green       <- "#18BC9C"  # Flatly teal
flatly_yellow     <- "#F1C40F"  # gold
light_red         <- "#E74C3C"  # Flatly red
flatly_red_dark   <- "#C0392B"  # darker red
flatly_blue       <- "#387ba8"  # Accent for lines
flatly_dark       <- "#2c3e50"  # blue of the theme
flatly_purple     <- "#A569BD"  # amethyst
flatly_gray_light <- "#ECF0F1"  # very light gray (bg)
flatly_gray_dark  <- "#7F8C8D"  # dark gray
flatly_border     <- "#BDC3C7"  # subtle borders

fixed_color <- light_red

dpi = 150
base_size <- 30
linewidth = 1.5
theme_set(theme_bw(base_size = base_size))

```


```{r, echo=FALSE, results='asis', warning=FALSE}
# sprtt_cit <- paste(format(citation("sprtt"), style = "text"), collapse = " ")
# sprtt_cit <- gsub("_(.+?)_", "<em>\\1</em>", sprtt_cit, perl = TRUE)
# 
# # Match the last angle-bracket URL by greedily capturing the prefix
# sprtt_cit <- sub("(?s)^(.*)&lt;\\s*(https?://[^&\\s]+)\\s*&gt;(.*)$",
#                  '\\1<br><a href="\\2" target="_blank" rel="noopener">\\2</a>\\3',
#                  sprtt_cit, perl = TRUE)
# sprtt_cit <- sub("(?s)^(.*)<\\s*(https?://[^>\\s]+)\\s*>(.*)$",
#                  '\\1<br><a href="\\2" target="_blank" rel="noopener">\\2</a>\\3',
#                  sprtt_cit, perl = TRUE)
# 
# cat(sprintf(
#   '<p class="author-line"><i>created by the</i> [sprtt](https://meikesteinhilber.github.io/sprtt/) <i>package</i><br>
#    <cite style="font-size:0.85em;color:#555;line-height:1.4;overflow-wrap:anywhere;">%s</cite></p>',
#   sprtt_cit
# ))
# 
sprtt_cit <- paste(format(citation("sprtt"), style = "text"), collapse = " ")
sprtt_cit <- gsub("_(.+?)_", "<em>\\1</em>", sprtt_cit, perl = TRUE)

# Remove URLs in angle brackets (both escaped & literal), plus a trailing dot if present
sprtt_cit <- gsub("&lt;\\s*https?://[^&\\s>]+\\s*&gt;\\.?","", sprtt_cit, perl=TRUE)
sprtt_cit <- gsub("<\\s*https?://[^>\\s]+\\s*>\\.?","", sprtt_cit, perl=TRUE)

# (Optional) also remove bare URLs that might appear without <...>
sprtt_cit <- gsub("\\bhttps?://[^\\s<>]+\\b\\.?","", sprtt_cit, perl=TRUE)

# Clean up leftover spaces/punctuation
sprtt_cit <- gsub("\\s+,", ",", sprtt_cit)
sprtt_cit <- gsub("\\s+\\.", ".", sprtt_cit)
sprtt_cit <- gsub("\\s{2,}", " ", sprtt_cit)
sprtt_cit <- trimws(sprtt_cit)

cat(sprintf(
  '<p class="author-line"><i>created by the</i> <a href="https://meikesteinhilber.github.io/sprtt/" target="_blank" rel="noopener">sprtt</a> <i>package</i><br>
   <cite style="font-size:0.85em;color:#555;line-height:1.4;">%s</cite></p>',
  sprtt_cit
))


```




<!-- <div class="toc-text-top"> -->
<!-- <p style="font-size: 1.5em; font-weight: bold; margin-top: 1em; margin-bottom: 0.5em; "> -->
<!-- $f_{exp}$ = `r pick_f_expected` -->
<!-- </p> -->
<!-- </div> -->

<br><br>
<br><br>

## Overview

<!-- ### Overview {#txt-overview .unlisted .unnumbered} -->

This report provides practical guidance for planning studies using **sequential ANOVA** (SPRT), where the final sample size is not fixed in advance.

Unlike traditional sample size analyses, this report cannot predict the exact sample size needed to reach a decision in a specific study.
Instead, it offers evidence-based recommendations derived from simulations, showing what sample sizes are typically required under various scenarios.
Thus, these benchmarks enable realistic resource planning.

::: {.alert .alert-warning}
The actual final sample size in any study may differ substantially from the following recommendations due to sampling variability and departures from the assumed effect structure.
:::


### Abbreviations

| Parameter | Description |
|:---|:-------------|
| $f_{\text{exp}}$ | Expected effect size (target effect) used for planning the sequential design |
| $f_{\text{true}}$ | True effect size in the simulated population |
| $\alpha$ | Type I error rate (probability of false positive) |
| $\beta$ | Type II error rate (probability of false negative) |
| $1-\beta$ | Target power. The desired probability of detecting a true effect.  |
| $k$ | Number of groups  |
| $N$ | Sample size  |
| $N_{\text{max}}$ | The maximum sample size when the researcher stops collecting data independent of the test decision. This sample size is only reached in the worst-case scenario. |
| $N_{\text{mean}}$ | The average sample size at which a decision is reached across simulations. In a single study, the required sample size is expected to be close to this value.|


### Content

**[Chapter I](#chapter-1)** illustrates the consequences of choosing a target effect size $f_{\text{exp}}$ across a range of possible true effects $f_{\text{true}}$. Although not specific to sequential designs, this perspective is essential for selecting a sensible expected effect size.

**[Chapter II](#chapter-2)** presents the core planning results for a sequential study, focusing on two benchmark cases: the true effect equals the specified value ($f_{\text{true}} = f_{\text{exp}}$) and there is no true effect ($f_{\text{true}} = 0$).

**[Chapter III](#chapter-3)** offers extended plots and tables to explore additional scenarios with more varied $f_{\text{true}}$ values.


### Technical details
<!-- ### Technical details {#txt-sim .unlisted .unnumbered} -->

The following results are based on a simulation with `r n_rep` iterations per condition.
Data were generated from a normal distribution, $\mathcal{N}(\mu,\sigma^2)$, under equal variances across groups and strictly balanced group sizes throughout data collection.

The analyses below use the following specifications:

 - $f_{exp}$ = `r pick_f_expected`

 - Power ($1-\beta$) = `r pick_power`

 - *k* groups = `r pick_k_groups`
 
 - $\alpha$ = 0.05
 
See XXX for the simulation code.

<br>

## I. Influence of $f_{\text{exp}}$ {#chapter-1}

For this report, the effect size was specified as $f_{\text{exp}} = `r pick_f_expected`$.

Choosing $f_{\text{exp}}$ is critical because it determines:

  - which effect sizes can be detected with the target power and
  
  - how much data are typically required to reach a decision.

::: {.alert .alert-info}
It is recommended to set $f_{\text{exp}}$ to the **minimum effect of interest**: power declines quickly for effects smaller than $f_{\text{exp}}$, whereas choosing a much larger $f_{\text{exp}}$ may shorten data collection but risks missing practically relevant effects just below that value.
:::


<!-- ### Power curve -->
<!-- ### Plot: Power curve {#power-curve .toc-only} -->

The plot below shows the power curve across possible true effects in the population, $f_{\text{true}}$.

The red color indicates that the power to detect a true effect of the corresponding size falls below the target power of `r pick_power`, suggesting the design is underpowered for such effect sizes.
The green color indicates that the power meets or exceeds the target power.

```{r, fig.height=10, fig.width=15, out.width="100%", fig.align="left"}
plot_cases <- df_all %>% 
  mutate(fill_group = factor(as.integer(f_simulated))) %>% 
  filter(f_expected == pick_f_expected,
         power == pick_power,
         k_groups == pick_k_groups
  ) %>% 
  filter(f_simulated != 0) %>% 
  group_by(
    f_simulated,
    f_expected,
    k_groups,
    alpha,
    power,
    distribution,
    sd,
    sample_ratio) %>% 
  mutate(
    decision_status_50 = if_else(decision != "continue sampling" & n <= q50_n, 1, 0),
    decision_status_75 = if_else(decision != "continue sampling" & n <= q75_n, 1, 0),
    decision_status_90 = if_else(decision != "continue sampling" & n <= q90_n, 1, 0),
    decision_status_95 = if_else(decision != "continue sampling" & n <= q95_n, 1, 0),
    decision_status_100 = if_else(decision != "continue sampling", 1, 0)
  ) %>% 
  summarize(
    error_rate = mean(decision_error),
    mean_n = mean(n),
    median_n = median(n),
    q90_n = quantile(n, 0.90),
  ) %>% mutate(
    simulated_power = if_else(f_simulated != 0, 1 - error_rate, NA),
    .after = power
  )

# 1) Build a dense x-grid and linearly interpolate simulated_power
rng  <- range(plot_cases$f_simulated)
grid <- tibble(f_simulated = seq(rng[1], rng[2], length.out = 1000))
grid$simulated_power <- with(plot_cases,
  approx(x = f_simulated, y = simulated_power, xout = grid$f_simulated,
         method = "linear", rule = 2)$y
)

# 2) Compute above/below and y-bounds for one ribbon layer
shade <- grid %>%
  mutate(
    above  = simulated_power >= pick_power,
    ymin   = pmin(simulated_power, pick_power),
    ymax   = pmax(simulated_power, pick_power)
  )

# 3) Plot: one ribbon (colored by above/below), then your original line/points
ggplot() +
  geom_ribbon(
    data = shade,
    aes(x = f_simulated, ymin = ymin, ymax = ymax, fill = above),
    alpha = 0.25, colour = NA
  ) +
  scale_fill_manual(values = c(`TRUE` = light_green, `FALSE` = light_red), guide = "none") +
  geom_line(data = plot_cases, aes(f_simulated, simulated_power),
            linewidth = 1.2, colour = flatly_dark) +
  geom_point(data = plot_cases, aes(f_simulated, simulated_power),
             size = 3.8, colour = flatly_blue, fill = flatly_blue,
             shape = 21, stroke = 1.2) +
  geom_hline(yintercept = pick_power, linetype = "dashed", colour = flatly_dark) +
  geom_segment(aes(x = pick_f_expected, xend = pick_f_expected, 
                 y = 0, yend = 1),  # Adjust yend to control where line stops
             linetype = "dashed", colour = flatly_dark) +
  annotate(
    "text",
    x = pick_f_expected,
    y = 1,  # Position text just above the line
    label = expression(italic(f)[exp]),
    hjust = 0.5,  # Center horizontally
    vjust = 0,    # Bottom of text at y position
    size = base_size * 0.25,
    colour = flatly_dark
  ) +
  scale_y_continuous(limits = c(0, 1.1), breaks = seq(0, 1, by = 0.25),
                     labels = scales::percent_format(accuracy = 1)) +
  scale_x_continuous(expand = expansion(mult = c(0.02, 0.02)),
                     breaks = unique(plot_cases$f_simulated)) +
  labs(
    title = "Simulated power across true effect sizes",
    x = expression(italic(f)[true]),
    y = "Simulated power",
    subtitle = glue::glue(
      "<i>f</i><sub>exp</sub> = {pick_f_expected}, ",
      "&alpha; = 0.05, 1 - &beta; = {pick_power}, groups = {pick_k_groups}"
    )
  ) +
  theme_minimal(base_size = base_size) +
  theme(
    text = element_text(colour = flatly_dark),   # <-- sets ALL text to blue
    plot.title = element_text(face = "bold", size = base_size, hjust = 0, colour = flatly_dark),
    plot.subtitle = ggtext::element_markdown(size = base_size*0.7, colour = "grey40"),
    axis.title = element_text(face = "bold"),
    axis.text  = element_text(colour = "grey20"),
    panel.grid.minor = element_blank(),
    panel.grid.major.x = element_blank(),
    legend.position = "none",
    plot.title.position = "plot"
  )  -> plot


if (pick_f_expected == 0.10){
  plot + annotate(
    "text",
    x = min(plot_cases$f_simulated),
    y = pick_power,
    label = paste0(" target power = ", percent(pick_power)),
    hjust = 0,
    vjust = 2,
    size = base_size * 0.25,
    colour = flatly_dark
  )
    
} else if (pick_f_expected == 0.15) {
    plot + annotate(
    "text",
    x = max(plot_cases$f_simulated) - 0.07,
    y = pick_power,
    label = paste0(" target power = ", percent(pick_power)),
    hjust = 0,
    vjust = 2,
    size = base_size * 0.25,
    colour = flatly_dark
  )
} else{
    plot + annotate(
    "text",
    x = min(plot_cases$f_simulated),
    y = pick_power + 0.1,
    label = paste0(" target power = ", percent(pick_power)),
    hjust = 0,
    vjust = 2,
    size = base_size * 0.25,
    colour = flatly_dark
  )
}

```

<br><br>



## II. Sample size recommendations {#chapter-2}

```{r}
pick_f_simulated = c(0, pick_f_expected)

table_cases <- df_all %>% 
  mutate(f_simulated = factor(f_simulated, levels = sort(unique(pick_f_simulated))),
         fill_group = factor(as.integer(f_simulated))) %>% 
  filter(f_expected == pick_f_expected,
         power == pick_power,
         k_groups == pick_k_groups
  ) %>% 
  filter(f_simulated %in% pick_f_simulated) %>% 
    group_by(
    f_simulated,
    f_expected,
    k_groups,
    alpha,
    power,
    distribution,
    sd,
    sample_ratio) %>% 
  mutate(
    decision_status_50 = if_else(decision != "continue sampling" & n <= q50_n, 1, 0),
    decision_status_75 = if_else(decision != "continue sampling" & n <= q75_n, 1, 0),
    decision_status_90 = if_else(decision != "continue sampling" & n <= q90_n, 1, 0),
    decision_status_95 = if_else(decision != "continue sampling" & n <= q95_n, 1, 0),
    decision_status_100 = if_else(decision != "continue sampling", 1, 0)
  ) %>% 
  group_by(f_simulated, f_expected, power) %>%
  summarize(
    decision_error_rate = mean(decision_error),
    fix_n = as.integer(mean(fix_n)),
    mean_n = as.integer(round(mean(n))),
    median_n = as.integer(median(n)),
    min_n = as.integer(min(n)),
    max_n = max(n),
    decision_rate_100 = sum(decision_status_100)/n(),
    q25_n = as.integer(round(quantile(n, 0.25))),
    q50_n = as.integer(round(quantile(n, 0.50))),
    q75_n = as.integer(round(quantile(n, 0.75))),
    q80_n = as.integer(round(quantile(n, 0.80))),
    q85_n = as.integer(round(quantile(n, 0.85))),
    q90_n = as.integer(round(quantile(n, 0.90))),
    q95_n = as.integer(round(quantile(n, 0.95))),
    sd_error_n  = sd(n)/sqrt(length((n))),
    decision_rate_50 = sum(decision_status_50)/n(),
    decision_rate_75 = sum(decision_status_75)/n(),
    decision_rate_90 = sum(decision_status_90)/n(),
    decision_rate_95 = sum(decision_status_95)/n()
  ) %>% mutate(
    simulated_power = if_else(f_simulated != 0, 1 - decision_error_rate, NA),
    .after = power
  ) %>% 
  select(-power) %>% 
    ungroup() %>%
    select(
    f_simulated,
    # f_expected,
    simulated_power,
    decision_error_rate,
    mean_n,
    median_n,
    min_n,
    max_n,
    # decision_rate_90,
    q75_n,
    q80_n,
    q85_n,
    q90_n,
    q95_n,
    fix_n
    # decision_rate_95,
  ) %>% 
  mutate()
  # mutate(f_simulated = as.double(f_simulated))
```

```{r}
recommendation <- table_cases %>%
  filter(q90_n == max(q90_n))

n_mean <- round(mean(table_cases$mean_n),0)
n_max <- recommendation$q90_n
```


::: {.alert .alert-info}
In short, it is <span style="color: #2c3e50; font-weight: bold;">recommended to plan for a maximum sample size of $N_{\text{max}} =$ `r n_max`</span>.<br>
With this $N_{\text{max}}$, the sequential ANOVA reaches a decision 90% of the time, even in the scenario that requires the most data, which is when $f_{\text{true}} =$ `r recommendation$f_simulated`.
While $N_{\text{max}}$ plans for the worst case, the <span style="color: #2c3e50; font-weight: bold;">expected sample size on average is $N_{\text{mean}} =$ `r n_mean`</span> in this scenario.
:::

In the following plot you can see a visualization of the simulated samples, where either the effect in the data is as expected or the effect is zero.
For a extended version of these results see **[Chapter III](#chapter-3)**.
The violin plot displays the variance of the sample sizes, to reach a final decision.

<!-- ### Plot: Sample size requirement {#plot .toc-only} -->

The numeric details are shown in the table.

```{r, fig.height=10, fig.width=15, out.width="100%", fig.align="left"}

# titles
title_html <- glue("<i>f</i><sub>exp</sub> = {pick_f_expected}")
caption_html <- glue(
  # "<i>f</i><sub>true</sub> = {pick_f_expected},<br>",
  "1 - &beta; = {pick_power}, &alpha; = 0.05,<br> groups = {pick_k_groups}"
)

df_all %>% 
  mutate(f_simulated = factor(f_simulated, levels = sort(unique(pick_f_simulated))),
         fill_group = factor(as.integer(f_simulated))) %>% 
  filter(f_expected == pick_f_expected,
         power == pick_power,
         k_groups == pick_k_groups
  ) %>% 
  filter(f_simulated %in% pick_f_simulated) %>%
  {. ->> cases} %>% 
  ggplot(aes(x = f_simulated, y = n)) +
  geom_violin(trim = FALSE, fill = light_green,
              scale = "count",
              linewidth = 0.3,
              alpha = 0.25) +
  geom_hline(yintercept = n_mean, linetype = "dashed", color = flatly_dark, linewidth = 0.8) +
  geom_hline(yintercept = n_max, linetype = "dashed", color = flatly_dark, linewidth = 0.8) +
  annotate("text", x = 2.5, y = n_mean + 5, 
           label = "italic(N)[mean]", parse = TRUE, vjust = -0.1,
           size = base_size * 0.25, color = flatly_dark) +
  annotate("text", x = 2.5, y = n_max + 5, 
           label = "italic(N)[max]", parse = TRUE, vjust = -0.1,
           size = base_size * 0.25, color = flatly_dark) +
  geom_point(aes(x = f_simulated, y = fix_n, color = "Fixed sample size"),
             position = position_dodge(0.9),
             shape = 18,
             size = 11) +
  geom_point(aes(x = f_simulated, y = mean_n, color = "Mean sample size"),
             position = position_dodge(0.9),
             shape = 15,
             size = 8) + 
  
  labs(
    x = "<i>f</i><sub>true</sub>",
    y = "<i>N</i>",
    title = "Required sample sizes to reach a decision",
    subtitle = glue::glue(
      "<i>f</i><sub>exp</sub> = {pick_f_expected}, ",
      "&alpha; = 0.05, 1 - &beta; = {pick_power}, groups = {pick_k_groups}"
    )) +
  scale_color_manual(
    name   = "Legend",
    values = c("Fixed sample size" = fixed_color,
               "Mean sample size"  = flatly_dark),
    labels = c("Fixed sample size" = "a priori power analysis",
               "Mean sample size"  = "mean sample size")
  ) +
  guides(
    color = guide_legend(override.aes = list(size = 5))
  ) +
  theme_minimal(base_size = base_size) +
  theme(text = element_text(colour = flatly_dark),
        plot.title = element_text(face = "bold", size = base_size,
                                  hjust = 0, colour = flatly_dark),
        plot.subtitle = ggtext::element_markdown(size = base_size*0.7, colour = "grey40"),
        plot.caption = element_markdown(),
        axis.title.x = element_markdown(),
        axis.title.y = element_markdown(angle = 180, vjust = 0.5),
        panel.grid.minor.y = element_blank(),
        panel.grid.major.x = element_blank(),
        legend.position = "right",
        legend.text = element_text(size = base_size * 0.7)
        ) -> p_violin
p_violin
```

<!-- ### Summary table {#table .toc-only} -->



```{r}
table_cases %>%
  ungroup() %>% 
  mutate(decision_error_rate = decision_error_rate) %>% 
  gt() %>%
  sub_missing(columns = simulated_power, missing_text = "-") %>% 
  tab_header(
    title = gt::html("<i>Summary table</i>"),
    subtitle = gt::html(glue("<i>f</i><sub>exp</sub> = {pick_f_expected}, &alpha; = 0.05, 1 - &beta; = {pick_power}, groups = {pick_k_groups}"))
  ) %>%
  # center all data columns
  cols_align(align = "center", columns = everything()) %>%
  # center column labels and the heading
  tab_options(
    heading.align = "left"
  ) %>% 
  cols_label(
    f_simulated         = gt::html("<i>f</i><sub>true</sub>"),
    # f_expected          = gt::html("<i>f</i><sub>exp</sub>"),
    simulated_power     = "simulated power",
    decision_error_rate = "Error rate %",
    fix_n               = html("Reference <i>N</i>:<br>fixed design"),
    mean_n              = "Mean",
    median_n            = "Median",
    min_n               = "Min",
    max_n               = "Max",
    # decision_rate_90    = "90% decision rate",
    q75_n               = "75%",
    q80_n               = "80%",
    q85_n               = "85%",
    q90_n               = "90%",
    q95_n               = "95%"
    # decision_rate_95    = "95% decision rate"
  ) %>%
   # high-level headers (spanners)
  tab_spanner(
    label   = "Sample size (N)",
    columns = c(mean_n, median_n, min_n, max_n)
  ) %>%
  tab_spanner(
    label   = html("<i>N</i> to reach decision rate (%)"),
    columns = c(q75_n, q80_n, q85_n, q90_n, q95_n)
  ) %>%
  # tab_spanner(
  #   label   = html("Reference fixed design N"),
  #   columns = c(fix_n)
  # ) %>%
  data_color(
    columns = q90_n,
    palette = grey_blue
  ) %>%
  data_color(
    columns = fix_n,
    palette = "darkgrey"
  ) %>%
  fmt_number(
    columns = where(is.double),
    decimals = 2
  ) %>% 
   tab_footnote(
    footnote = html(glue("grand average: <i>N</i><sub>mean</sub> = {n_mean}")),
    locations = cells_column_labels(columns = mean_n)
  ) %>% 
   tab_footnote(
    footnote = html(glue("recommended <i>N</i><sub>max</sub> = {n_max}")),
    locations = cells_column_labels(columns = q90_n)
  )
```

::: {.alert .alert-info}
In most cases, the 90% decision percentile is numerically very close to the fixed sample size.
Thus, as a rule of thumb, the fixed sample size is generally a good choice for $N_{\text{max}}$.
:::

## III. Extended insights {#chapter-3}

### Plot: Sample size and varing $f_{\text{true}}$ {#plot .toc-only}

```{r}
pick_f_simulated = c(0,
                     pick_f_expected - 0.05,
                     pick_f_expected,
                     pick_f_expected + 0.05)
```


<!-- ### Required sample sizes {#extended-violin .toc-only} -->

This violin plot shows the distribution of required sample sizes $n$ across simulations for different assumed true effects $f_{\text{true}}$.
Each violin summarizes how often a given $n$ occurred: wider sections indicate that sample sizes in that range were more frequent.

The violin colors indicate whether the test achieves the target power at each true effect.

  - **Green** marks settings where $f_{\text{true}} \geq f_{\text{exp}}$ (or $f_{\text{true}} = 0$); at these settings the test reaches the target power $1-\beta$ = `r pick_power`.
  
  - **Red** marks settings where power falls short, so such effects would often not be detected with the specified power `r pick_power`. If `f_expected = 0.1` is selected, no red violin is shown as it is outside of the simulated scope.


The red diamond marks the fixed sample size from an a priori power analysis, and the blue square shows the mean sample size observed across simulations.


```{r, fig.height=10, fig.width=15, out.width="100%", fig.align="left"}
# violin_colors <- c(light_blue, hell_rosa, light_blue, light_blue)

# title_html <- glue("<i>f</i><sub>exp</sub> = {pick_f_expected}")
caption_html <- glue(
  "1 - &beta; = {pick_power}, &alpha; = 0.05,<br>",
  "groups = {pick_k_groups}"
)


p_violin <- df_all %>%
  mutate(
    f_simulated = factor(f_simulated, levels = sort(unique(pick_f_simulated))),
    fill_label = ifelse(f_simulated == pick_f_expected - 0.05,
                        "not enough power",
                        "enough power")
  ) %>%
  filter(
    f_expected == pick_f_expected,
    power == pick_power,
    k_groups == pick_k_groups
  ) %>%
  filter(f_simulated %in% pick_f_simulated) %>%
  ggplot(aes(x = as.factor(f_simulated), y = n, fill = fill_label)) +
  
  # violins (fill legend only)
  geom_violin(
    trim = FALSE,
    scale = "count",
    # draw_quantiles = c(0.25, 0.50, 0.75),
    # linewidth = 0.1,
    color = "lightgrey",
    alpha = 0.25
  ) +
  scale_fill_manual(
    name = "Power",
    values = c("enough power" = light_green,
               "not enough power" = light_red)
  ) +
  
  # red diamond = fixed sample size
  geom_point(
    aes(y = fix_n, color = "Fixed sample size"),
    position = position_dodge(0.9),
    shape = 18,     # diamond, no border
    size  = 7,
    stroke = 0      # ensures no black outline
  ) +
  
  # blue square = mean sample size
  geom_point(
    aes(y = mean_n, color = "Mean sample size"),
    position = position_dodge(0.9),
    shape = 15,     # square, no border
    size  = 6,
    stroke = 0      # ensures no black outline
  ) +
scale_color_manual(
  name   = "Legend",
  values = c("Fixed sample size" = fixed_color,
             "Mean sample size"  = flatly_dark),
  labels = c("Fixed sample size" = "a priori power analysis",
             "Mean sample size"  = "mean sample size")
) +
  labs(
    x = "<i>f</i><sub>true</sub>",
    y = "<i>N</i>",
    title = "Required sample sizes to reach a decision",
    subtitle = glue::glue(
      "<i>f</i><sub>exp</sub> = {pick_f_expected}, ",
      "&alpha; = 0.05, 1 - &beta; = {pick_power}, groups = {pick_k_groups}"
    )
  ) +
  
  # clean legend appearance
  guides(
    fill  = guide_legend(override.aes = list(shape = NA)),  # patches only
    color = guide_legend(override.aes = list(stroke = 0, size = 5)) # points only
  ) +
  theme_minimal(base_size = base_size) +
  theme(
    text = element_text(colour = flatly_dark),
    legend.key = element_blank(),  # no background box around keys
    legend.text = element_text(size = base_size * 0.7),
    # plot.title = element_markdown(),
    # plot.subtitle = element_markdown(),
    plot.caption = element_markdown(),
    axis.title.x = element_markdown(),
    axis.title.y = element_markdown(angle = 180, vjust = 0.5),
    # panel.grid.minor.y = element_blank(),
    panel.grid.minor.x = element_blank(),
    panel.grid.major.x = element_blank(),
    plot.title = element_text(face = "bold", size = base_size, hjust = 0, colour = flatly_dark),
    plot.subtitle = ggtext::element_markdown(size = base_size*0.7, colour = "grey40")
  ) 

p_violin


```


<!-- ### Summary table {#extended-table .toc-only} -->

```{r}
table_cases <- df_all %>% 
  mutate(f_simulated = factor(f_simulated, levels = sort(unique(pick_f_simulated))),
         fill_group = factor(as.integer(f_simulated))) %>% 
  filter(f_expected == pick_f_expected,
         power == pick_power,
         k_groups == pick_k_groups
  ) %>% 
  filter(f_simulated %in% pick_f_simulated) %>% 
    group_by(
    f_simulated,
    f_expected,
    k_groups,
    alpha,
    power,
    distribution,
    sd,
    sample_ratio) %>% 
  mutate(
    decision_status_50 = if_else(decision != "continue sampling" & n <= q50_n, 1, 0),
    decision_status_75 = if_else(decision != "continue sampling" & n <= q75_n, 1, 0),
    decision_status_90 = if_else(decision != "continue sampling" & n <= q90_n, 1, 0),
    decision_status_95 = if_else(decision != "continue sampling" & n <= q95_n, 1, 0),
    decision_status_100 = if_else(decision != "continue sampling", 1, 0)
  ) %>% 
  group_by(f_simulated, f_expected, power) %>%
  summarize(
    decision_error_rate = mean(decision_error),
    fix_n = as.integer(mean(fix_n)),
    mean_n = as.integer(round(mean(n))),
    median_n = as.integer(median(n)),
    min_n = as.integer(min(n)),
    max_n = max(n),
    decision_rate_100 = sum(decision_status_100)/n(),
    q25_n = as.integer(round(quantile(n, 0.25))),
    q50_n = as.integer(round(quantile(n, 0.50))),
    q75_n = as.integer(round(quantile(n, 0.75))),
    q80_n = as.integer(round(quantile(n, 0.80))),
    q85_n = as.integer(round(quantile(n, 0.85))),
    q90_n = as.integer(round(quantile(n, 0.90))),
    q95_n = as.integer(round(quantile(n, 0.95))),
    sd_error_n  = sd(n)/sqrt(length((n))),
    decision_rate_50 = sum(decision_status_50)/n(),
    decision_rate_75 = sum(decision_status_75)/n(),
    decision_rate_90 = sum(decision_status_90)/n(),
    decision_rate_95 = sum(decision_status_95)/n()
  ) %>% mutate(
    simulated_power = if_else(f_simulated != 0, 1 - decision_error_rate, NA),
    .after = power
  ) %>% 
  select(-power) %>% 
    ungroup() %>%
    select(
    f_simulated,
    # f_expected,
    simulated_power,
    decision_error_rate,
    mean_n,
    median_n,
    min_n,
    max_n,
    # decision_rate_90,
    q75_n,
    q80_n,
    q85_n,
    q90_n,
    q95_n,
    fix_n
    # decision_rate_95,
  ) %>% 
  mutate()
  # mutate(f_simulated = as.double(f_simulated))

# num_cols <- colnames(table_cases)
num_cols <- c("f_simulated", "simulated_power", "decision_error_rate")

table_cases %>%
  ungroup() %>% 
  # mutate(decision_error_rate = decision_error_rate) %>% 
  gt() %>%
    # Percent columns (show "-" for NA)
  sub_missing(columns = simulated_power, missing_text = "-") %>% 
  tab_header(
    title = gt::html("<i>Summary table</i>"),
    subtitle = gt::html(glue("<i>f</i><sub>exp</sub> = {pick_f_expected}, &alpha; = 0.05, 1 - &beta; = {pick_power}, groups = {pick_k_groups}"))
  ) %>%
  # center all data columns
  cols_align(align = "center", columns = everything()) %>%
  # center column labels and the heading
  tab_options(
    heading.align = "left"
  ) %>% 
  cols_label(
    f_simulated         = gt::html("<i>f</i><sub>true</sub>"),
    # f_expected          = gt::html("<i>f</i><sub>exp</sub>"),
    simulated_power     = "simulated power",
    decision_error_rate = "Error rate %",
    fix_n               = html("Reference <i>N</i>:<br>fixed design"),
    mean_n              = "Mean",
    median_n            = "Median",
    min_n               = "Min",
    max_n               = "Max",
    # decision_rate_90    = "90% decision rate",
    q75_n               = "75%",
    q80_n               = "80%",
    q85_n               = "85%",
    q90_n               = "90%",
    q95_n               = "95%"
    # decision_rate_95    = "95% decision rate"
  ) %>%
   # high-level headers (spanners)
  tab_spanner(
    label   = "Sample size (N)",
    columns = c(mean_n, median_n, min_n, max_n)
  ) %>%
  tab_spanner(
    label   = html("<i>N</i> to reach decision rate (%)"),
    columns = c(q75_n, q80_n, q85_n, q90_n, q95_n)
  ) %>%
  data_color(
    columns = all_of(num_cols),
    rows    = as.numeric(as.character(f_simulated)) < pick_f_expected &
              as.numeric(as.character(f_simulated)) != 0,
    colors  = light_red, alpha = 0.25,
    autocolor_text = FALSE) %>% 
  data_color(
    columns = q90_n,
    palette = grey_blue
  ) %>%
  data_color(
    columns = fix_n,
    palette = "darkgrey"
  ) %>%
  fmt_number(
    columns = where(is.double),
    decimals = 2
  )


```

<!-- ### Sequential vs fixed design -->

<br><br>

### Plot: Sample size and varing $f_{\text{exp}}$ {#sample-size-diff .toc-only}

The next plot below visualizes the required sample sizes, when the true value is set and one uses different specification of $f_{\text{exp}}$.
Here you can see how the specification of $f_{\text{exp}}$ influences the sample sizes also in direct comparison to a fixed sample plan.
Sequential designs maintain efficiency despite underestimating $f_{\text{exp}}$, whereas fixed designs are locked into their initial specification -- a key advantage demonstrated in this plot

```{r, fig.height=10, fig.width=15, out.width="100%", fig.align="left"}
pick_f_simulated = pick_f_expected

# titles
title_html <- glue("<i>f</i><sub>true</sub> = {pick_f_simulated}")
subtitle_html <- glue(
  # "<i>f</i><sub>true</sub> = {pick_f_expected},<br>",
  "1 - &beta; = {pick_power}, &alpha; = 0.05,<br> groups = {pick_k_groups}"
)

df_all %>% 
  mutate(f_simulated = factor(f_simulated, levels = sort(unique(pick_f_simulated))),
         fill_group = factor(as.integer(f_simulated))
         ) %>% 
  filter(f_simulated == pick_f_simulated,
         f_expected <= pick_f_simulated,
         power == pick_power,
         k_groups == pick_k_groups
  ) %>%
  mutate(violin_color = if_else(f_expected < pick_f_expected & 
                                f_expected != 0, 
                                light_green, light_green),
         f_expected = factor(f_expected)) %>% 
  group_by(f_expected) %>% 
  {. ->> cases} %>% 
  ggplot(aes(x = f_expected, y = n)) +
  geom_violin(aes(fill = violin_color), trim = FALSE,
              scale = "count",
              linewidth = 0.3,
              alpha = 0.25) +
  scale_fill_identity() +
  geom_point(aes(x = f_expected, y = fix_n, color = "Fixed sample size"),
             position = position_dodge(0.9),
             shape = 18,
             size = 9) +
  geom_point(aes(x = f_expected, y = mean_n, color = "Mean sample size"),
             position = position_dodge(0.9),
             shape = 15,
             size = 6) + 
  labs(
    x = "<i>f</i><sub>exp</sub>",
    y = "<i>N</i>",
    title = "Required sample sizes to reach a decision",
    subtitle = glue::glue(
      "<i>f</i><sub>true</sub> = {pick_f_simulated}, ",
      "&alpha; = 0.05, 1 - &beta; = {pick_power}, groups = {pick_k_groups}"
    )) +
  scale_color_manual(
    name   = "Legend",
    values = c("Fixed sample size" = fixed_color,
               "Mean sample size"  = flatly_dark),
    labels = c("Fixed sample size" = "a priori power analysis",
               "Mean sample size"  = "mean sample size")
  ) +
  guides(
    color = guide_legend(override.aes = list(size = 5))
  ) +
  theme_minimal(base_size = base_size) +
  theme(text = element_text(colour = flatly_dark),
        plot.title = element_text(face = "bold", size = base_size, hjust = 0,
                                colour = flatly_dark),
        plot.subtitle = ggtext::element_markdown(size = base_size*0.7, colour = "grey40"),
        plot.caption = element_markdown(),
        axis.title.x = element_markdown(),
        axis.title.y = element_markdown(angle = 180, vjust = 0.5),
        panel.grid.minor.y = element_blank(),
        panel.grid.major.x = element_blank(),
        legend.position = "right",
        legend.text = element_text(size = base_size * 0.7)
        ) -> p_violin 
p_violin
```


<br><br>

### Plot: Cumulative decisions {#extended-cumulative .toc-only}

```{r, fig.height=10, fig.width=15, out.width="100%", fig.align="left"}
df_cum <- df_all %>%
  filter(f_expected == pick_f_expected,
         power      == pick_power,
         k_groups   == pick_k_groups) %>% 
  filter(f_simulated == 0 |
         f_simulated >= pick_f_expected) %>% 
  filter(decision != "continue sampling") %>%
  transmute(f_simulated,fix_n, n_decision = n) %>% 
  group_by(f_simulated) %>%
  arrange(n_decision, .by_group = TRUE) %>%
  mutate(cum_prop = row_number() / n()) %>%
  ungroup()

# 4) Find the minimum n that achieves at least 90% decided
cut90 <- df_cum %>%
  group_by(f_simulated) %>%
  summarise(n_at_90 = min(n_decision[cum_prop >= 0.90]), .groups = "drop")

# 5) Plot: ECDF of decision n, with a 90% line and vertical markers at n_at_90
ggplot(df_cum, aes(x = n_decision, y = cum_prop, colour = factor(f_simulated), group = f_simulated)) +
  geom_step(linewidth = 1.1) +
  # Horizontal 90% line
  geom_hline(yintercept = 0.90, linetype = "dotted", colour = flatly_dark) +
  geom_vline(xintercept = unique(df_cum$fix_n), color = flatly_dark,  linetype = "dashed") +
  annotate(
  "text",
  x = unique(df_cum$fix_n) + (unique(df_cum$fix_n) * 0.07),
  y = 0.05,
  label = "fixed sample size",
  angle = 90,         # rotate text
  hjust = 0.1,
  vjust = 0.1,
  size = base_size * 0.25,
  colour = flatly_dark
) +
  scale_y_continuous(
    limits = c(0, 1),
    breaks = c(0, 0.25, 0.5, 0.75, 0.9, 1),
    labels = percent_format(accuracy = 1)
  ) +
  scale_color_brewer(palette = "Set2") +   # modern pastel Flatly-compatible palette
  labs(
    x = "<i>N</i>",
    y = "",  #"Cumulative proportion\nwith a decision",
    colour = expression(italic(f)[true]),
    title = "Cumulative decision proportions across simulated\neffect sizes",
    # subtitle = "Dashed line: 90% decision threshold"
    subtitle = glue::glue(
      "<i>f</i><sub>exp</sub> = {pick_f_expected}, ",
      "&alpha; = 0.05, 1 - &beta; = {pick_power}, groups = {pick_k_groups}"
    )
  ) +
  theme_minimal(base_size = base_size) +
  theme(
    plot.title = element_text(face = "bold", size = base_size, hjust = 0, colour = flatly_dark),
    plot.subtitle = ggtext::element_markdown(size = base_size*0.7, colour = "grey40"),
    panel.grid.minor = element_blank(),
    panel.grid.major.x = element_blank(),
    #legend.position = "bottom",
    # legend.box = "horizontal",
    legend.title = element_text(face = "bold"),
    axis.title = element_text(face = "bold"),
    plot.title.position = "plot",
    axis.title.x = ggtext::element_markdown()
  )
```
